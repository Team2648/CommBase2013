// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2648.CommBase2013.subsystems;
import org.usfirst.frc2648.CommBase2013.RobotMap;
import org.usfirst.frc2648.CommBase2013.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc2648.CommBase2013.Robot;
/**
 *This piece of code represents the drivetrain, although, you may notice that the controllers
 * declared here actually reference other things from RobotMap. Remember to only reference the
 * variables declared here. DO NOT TRY TO USE VARIABLES DIRECTLY FROM ROBOTMAP. It won't go over
 * well.
 */
public class DriveTrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController left = RobotMap.driveTrainLeft;
    SpeedController right = RobotMap.driveTrainRight;
    RobotDrive robotDrive21 = RobotMap.driveTrainRobotDrive21;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new ArcadeDrive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        /*
         * This is where the subsystem makes its decision on what it should when no other command
         * needs to be executing within this subsystem, for the drivetrain subsystem, this should
         * always be the ArcadeDrive command. That way driving the robot around always takes 
         * precedence.
         */
    }
    /*
     * This is what the ArcadeDrive command uses to drive about, it does seem a bit wierd the way
     * this has to be done, but this is the way to do it.
     */
    public void drive()
    {
        robotDrive21.arcadeDrive(Robot.oi.j1.getY(), -Robot.oi.j1.getX());
        //System.out.println(Robot.driveTrain.left.get() + " || " +Robot.driveTrain.right.get());
    }
    /*
     * An accessory command, not used anywhere in particular if I remember correctly, but good
     * practice to always have one of these that drives motors.
     */
    public void stop()
    {
        robotDrive21.drive(0, 0);
    }
    public void setLeftRightMotors(double lspeed, double rspeed){
        robotDrive21.setLeftRightMotorOutputs(lspeed, rspeed);
    }
}
